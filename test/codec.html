<html>
<head>
	<title>video-stream.js - Codec</title>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="manifest" href="basic.manifest.json">
	
	<link rel="icon" type="image/png" href="https://avatars3.githubusercontent.com/u/20301426?v=3&s=16" sizes="16x16">
	<link rel="icon" type="image/png" href="https://avatars3.githubusercontent.com/u/20301426?v=3&s=32" sizes="32x32">
	<link rel="icon" type="image/png" href="https://avatars3.githubusercontent.com/u/20301426?v=3&s=96" sizes="96x96">
	
	<script type="application/javascript" src="../build/video-stream.min.js"></script>
	<!-- <script type="application/javascript" src="https://github.com/2b2/video-stream.js/releases/download/v0.1.1/video-stream.min.js"></script> -->
	<style>
	body{
		margin: 0px;
		padding: 0px;
		max-width: 100vw;
		background-color: #efefef;
	}
	#capture{
		display: none;
	}
	#capture-frame{
		width: 100%;
		height: 100vh;
		object-fit: contain;
	}
	.mirror-frame{
		-moz-transform: scale(-1, 1);
		-webkit-transform: scale(-1, 1);
		-o-transform: scale(-1, 1);
		transform: scale(-1, 1);
	}
	#options{
		display: flex;
		align-items: flex-start;
		margin: 0px 0px 10px 0px;
		padding: 5px;
		color: #6e6e6e;
		border-bottom: 2px solid #0090ef;
	}
	#options label{
		display: block;
		padding: 5px 10px;
		width: 200px;
		border-right: 2px solid #0090ef;
	}
	#options label > span{
		display: inline-block;
		padding-top: 3px;
		-webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
	}
	#options label .flip-switch, #options label select{
		float: right;
	}
	#options label select{
		width: 100%;
		max-width: 60%;
	}
	.flip-switch{
		position: relative;
		display: inline-block;
		width: 2.5em;
		height: 1em;
	}
	.flip-switch .flip-switch-slider{
		position: absolute;
		margin-left: -6px;
		top: 0px; left: 0px; width: 100%; height: 100%;
		background: #7e7e7e; border: 3px solid #7e7e7e; border-radius: 6px;
	}
	.flip-switch input[type="checkbox"]{
		display: none;
	}
	.flip-switch input[type="checkbox"]:checked + .flip-switch-slider{
		background: #0090ef; border-color: #0090ef; 
	}
	.flip-switch .flip-switch-slider:before{
		position: absolute;
		top: 0px; bottom: 0px; left: 0px; right: auto; width: 50%;
		content: "";
		background: #ffffff; border: 3px solid #ffffff; border-radius: 4px;
	}
	.flip-switch input[type="checkbox"]:checked + .flip-switch-slider:before{
		left: auto; right: 0px;
	}
	</style>
</head>
<body>
	<form id="options" action="" autocomplete="on">
	<label>
		<span>Device:</span>
		<select id="select-device"></select> 
	</label>
	<label>
		<span>Mirror Video:</span>
		<div id="mirror-video" class="flip-switch">
			<input type="checkbox">
			<div class="flip-switch-slider"></div>
		</div>
	</label>
	</form>
	
	<video id="capture" autoplay></video>
	<canvas id="capture-frame"></canvas>
	
	<script type="application/javascript">
		'use strict';
		
		var resolution = VideoStream.Resolution.VGA;
		
		var video = document.querySelector('#capture');
		var canvas = document.querySelector('#capture-frame');
		
		// fill #select-device <select> element with aviable video devices
		var selectDevice = document.querySelector('#select-device');
		VideoStream.ui.deviceSelector(selectDevice);
		// add change listener to device selection
		selectDevice.addEventListener('change', function(){
			videoStream.stop();
			videoStream.setupVideoOnlyStream(resolution, {deviceId: selectDevice.options[selectDevice.selectedIndex].value})
			.then(function(){videoStream.play();})
			.catch(function(e){console.log(e);});
		});
		
		
		// checkbox toggle listener
		var mirrorVideoCheckbox = document.querySelector('#options #mirror-video input[type="checkbox"]');
		var mirrorVideo = function(){
			if(mirrorVideoCheckbox.checked){
				canvas.setAttribute('class', 'mirror-frame');
			}else{
				canvas.removeAttribute('class');
			}
		};
		mirrorVideo();
		mirrorVideoCheckbox.addEventListener('click', mirrorVideo, false);
		
		// create new VideoStream
		var videoStream = new VideoStream(video);
		// start new video stream in above set resolution with the default video input device
		videoStream.setupVideoOnlyStream(resolution)
		.then(startCapture)
		.catch(function(e){console.log(e);});
		
		function startCapture(){
			// set canvas width and height to match video resolution
			canvas.width = video.videoWidth;
			canvas.height = video.videoHeight;
			
			// project the video onto the canvas
			var videoCanvas = videoStream.createVideoCanvas(canvas);
			// set the used GLSL shaders to the included grayscale fragment shader
			// (the vertex shader is the default one which is fine most of the time)
			videoCanvas.setShaders({fragment: `
				precision mediump float;
				
				const mat3 SOBEL_X = mat3(
					-1, 0, 1,
					-2, 0, 2,
					-1, 0, 1
				);
				const mat3 SOBEL_Y = mat3(
					-1, -2, -1,
					 0,  0,  0,
					 1,  2,  1
				);
				
				varying vec2 v_coordinate;
				
				uniform sampler2D texture;
				
				uniform vec2 u_textureSize;
				
				void main(){
					vec2 onePixel = 1.0 / u_textureSize;
					
					vec3 rgbColor = texture2D(texture, v_coordinate).rgb;
					float y = 0.299 * rgbColor.r + 0.587 * rgbColor.g + 0.114 * rgbColor.b;
					
					float chroma = 0.0;
					if(v_coordinate.y < 0.5){
						//cb
						if(v_coordinate.x < 0.5){
							vec3 rgbColorQuad = (
								texture2D(texture, v_coordinate * 2.0).rgb
								+ texture2D(texture, (v_coordinate * 2.0) + vec2(0, onePixel.y)).rgb
								+ texture2D(texture, (v_coordinate * 2.0) + vec2(onePixel.x, 0)).rgb
								+ texture2D(texture, (v_coordinate * 2.0) + vec2(onePixel.x, onePixel.y)).rgb
							) / 4.0;
							float yQuad = 0.299 * rgbColorQuad.r + 0.587 * rgbColorQuad.g + 0.114 * rgbColorQuad.b;
							chroma = 0.433 * (rgbColorQuad.b - (yQuad - 0.5));
						}
						//cr
						else{
							vec3 rgbColorQuad = (
								texture2D(texture, (v_coordinate - vec2(0.5, 0.0)) * 2.0).rgb
								+ texture2D(texture, ((v_coordinate - vec2(0.5, 0.0)) * 2.0) + vec2(0, onePixel.y)).rgb
								+ texture2D(texture, ((v_coordinate - vec2(0.5, 0.0)) * 2.0) + vec2(onePixel.x, 0)).rgb
								+ texture2D(texture, ((v_coordinate - vec2(0.5, 0.0)) * 2.0) + vec2(onePixel.x, onePixel.y)).rgb
							) / 4.0;
							float yQuad = 0.299 * rgbColorQuad.r + 0.587 * rgbColorQuad.g + 0.114 * rgbColorQuad.b;
							chroma = 0.877 * (rgbColorQuad.r - (yQuad - 0.5));
						}
					}
					
					gl_FragColor = vec4(y, chroma, 0.0, 1.0);
				}
			`});
			var gl = videoCanvas.getGlContext();
			var textureSizeLocation = gl.getUniformLocation(videoCanvas.getGlProgram(), 'u_textureSize')
			gl.uniform2f(textureSizeLocation, video.videoWidth, video.videoHeight);
			
			var frameCount = 0;
			var canvasUpdate = videoCanvas.update;
			videoCanvas.update = function(){
				if((++frameCount) == 2){
					/*
					var lumaData = new Uint8Array(video.videoWidth * video.videoHeight);
					this.gl.readPixels(
						0, 0, video.videoWidth, video.videoHeight, this.gl.RED, this.gl.UNSIGNED_BYTE, lumaData
					);
					
					var chromaData = new Uint8Array(Math.floor(video.videoWidth * video.videoHeight * 0.5));
					this.gl.readPixels(
						0, 0, video.videoWidth, Math.floor(video.videoHeight * 0.5), this.gl.GREEN, this.gl.UNSIGNED_BYTE, chromaData
					);
					*/
					var data = new Uint8Array(video.videoWidth * video.videoHeight * 3);
					this.gl.readPixels(
						0, 0, video.videoWidth, video.videoHeight, this.gl.RGB, this.gl.UNSIGNED_BYTE, data
					);
					
					console.log(data.length);
					
					this.stop();
					videoStream.stop();
					
					var blob = new Blob(data, {type: 'octet/stream'});
					//saveAs(blob, 'test.bin');
					//var url = window.URL.createObjectURL(blob);
					//location.href = url;
					//window.URL.revokeObjectURL(url);
				}
				canvasUpdate.call(this);
			};
			
			// start the updating of the canvas
			videoCanvas.start();
		}
	</script>
</body>
</html>